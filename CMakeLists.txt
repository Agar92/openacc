project(Test)
cmake_minimum_required(VERSION 2.8)
aux_source_directory(. SRC_LIST)
add_executable(${PROJECT_NAME} ${SRC_LIST} "nbody.cpp")

#"use OpenAcc instead of OpenMP" - this prompt will be in CMakeCache.txt and in compilation output.
#CACHE - itwill be added in CMakeCache.txt.
#BOOL - it is a bool variable ("ON", "OFF").
set(ACC "OFF" CACHE BOOL "use OpenAcc instead of OpenMP")
set(CUDA "OFF" CACHE BOOL "use CUDA headers for using cudaMemcpy() function with OpenAcc")
#in these lines is checked if the compiler supports:
##ifdef  OPENACC - OPENACC
##ifndef OPENACC - OpenMP for C++.
#the keyword REQUIRED means that if does not support, the compilation aborts (strict condition).
#Check if the compiler supports OpenAcc:
if(ACC)
    find_package(OpenACC REQUIRED)
else()
    find_package(OpenMP REQUIRED COMPONENTS CXX)
endif()

if(ACC)
####    This line tells the compiler to define "#define OPENACC" in the code and compile it
        target_compile_definitions(${PROJECT_NAME} PRIVATE OPENACC)
####    this line allows to set compiler flags automatically generated by the compiler.
####    I do not need it because will write -DCMAKE_CXX_FLGAS="..." myself.
        set_target_properties(${testname} PROPERTIES COMPILE_FLAGS ${OpenACC_CXX_FLAGS})
endif()

if(CUDA)
target_compile_definitions(${PROJECT_NAME} PRIVATE CUDA)
endif()

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17")
find_package(OpenMP)
if(OPENMP_FOUND)
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}")
endif()
